## Java笔记
1.数据类型：整型（int, short, long, byte），浮点型（float, double），字符类型（char），布尔类型（boolean）  
位运算符：&（与）、|（或）、^（异或）、~（非） 

2.StringBuffer是线程安全的，效率稍低，允许采用多线程的方式执行添加或删除字符的操作；如果所有字符串在一个单线程中编辑，则应该用StringBuilder替代

3.switch的case标签可以是类型为char、short、byte、int（或其包装器类Character、Short、Byte、Integer）的常量表达式；枚举常量；从Java 7.0开始，可以是字符串

4.允许将一个数组变量拷贝给另一个数组变量，两个变量将引用同一个数组；快速打印二维数组可以调用Arrays.deepToString(a)

5.类之间的关系
- 依赖（uses-a），如果类A的方法操纵类B的对象，则是类A依赖于类B，A本身并不需要引用B的实例作为成员变量；虚线箭头从A指向B；应尽可能将相互依赖的类减至最少，降低耦合度
- 聚合（has-a），类A的对象包含类B的对象
- 继承（is-a），实线空心三角箭头
- 接口实现，虚线空心三角箭头

6.一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用

7.在每一个方法中，关键字this表示隐式参数；参数有两种类型：基本数据类型和对象引用

8.注意不要编写返回引用可变对象的访问器方法，如果需要应该首先对它进行克隆

9.类的静态方法不能操作类对象，可以认为静态方法是没有this参数的方法，以下情况下使用静态方法：
- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
- 一个方法只需访问类的静态域
- 类使用工厂方法产生不同风格的格式对象 

10.按值调用表示方法接受的是调用者提供的值；按引用调用表示方法接受的是调用者提供的变量地址；一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java总是采用按值调用，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容

11.不能有两个名字相同、参数类型也相同却返回不同类型值的方法；方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。允许子类将覆盖方法的返回类型定义为原返回类型的子类型

12.调用构造器步骤：
1. 所有数据域被初始化为默认值
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
4. 执行这个构造器的主体

13.finalize方法将在垃圾回收器清除对象之前调用，不要依赖使用finalize方法回收任何短缺的资源

14.Java中所有继承都是公有继承，没有C++中的私有继承和保护继承；子类不能直接地访问超类的私有域

15.如果子类的构造器没有显式地调用超类的构造器，则自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中没有显式地调用超类的其他构造器，则Java编译器报错

16.this用途：一是引用隐式参数，二是调用该类的其他构造器；super用途：一是调用超类的方法，二是调用超类的构造器

17.一个对象变量可以指示多种实际类型的现象被称为多态，Java中对象变量是多态的，一个超类变量既可以引用一个超类对象，也可以引用超类的任何一个子类的对象，也可以称为置换法则。可以将一个子类对象赋值给超类变量，但不能将一个超类的引用赋值给子类变量

17.在运行时能够自动地选择调用哪个方法的现象称为动态绑定，下面是调用对象方法的过程：
- 编译器查看对象的声明类型和方法名
- 编译器将查看调用方法时提供的参数类型
- 如果是private、static、final方法或构造器，那个编译器将可以准确地知道应该调用哪个方法，即静态绑定
- 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与所引用对象的实际类型最适合的那个类的方法。虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法  

18.在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别地，如果超类方法是public，子类方法一定要声明为public

19.阻止继承：final类和方法。不允许被继承的类被称为final类，类中的特定方法也能被声明为final，这时子类不能覆盖该方法；如果将一个类声明为final，只有其中的方法自动地成为final，不包括域。主要目的是确保它们不会在子类中改变语义

20.只能在继承层次内进行类型转换；在将超类转换成子类之前，应该使用instanceof进行检查。一般情况下，应该尽量少用类型转换和instanceof运算符

21.类即使不含抽象方法，也可以将类声明为抽象类；抽象类不能被实例化，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象

22.访问修饰符：
- 仅对本类可见-private
- 对所有类可见-public
- 对本包和所有子类可见-protected
- 对本包可见-默认，不需要修饰符   

23.Java中，只有基本类型不是对象；所有的数组类型，不管是对象数组还是基本类型数组都扩展与Object类

24.Java语言要求equals具有以下特性：自反性、对称性、传递性、一致性、对于任何非空引用x,x.equals(null)返回false。如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测；如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较

25.对象包装器（Integer、Long等）是不可变的，即一旦构造了包装器，就不予许更改包装在其中的值。同时，对象包装器还是final，因此不能定义他们的子类

26.能够分析类能力的程序称为反射。反射机制可以用来：
- 在运行中分析类的能力
- 在运行中查看对象，例如编写一个toString方法供所有类使用
- 实现通用的数组操作代码
- 利用Method对象，这个对象很像C++中的函数指针

27.继承设计技巧
- 将公共操作和域放在超类
- 不要使用受保护的域
- 使用继承实现"is-a"关系
- 除非所有继承的方法都有意义，否则不要使用继承
- 在覆盖方法时，不要改变预期的行为
- 使用多态，而非类型信息
- 不要过多地使用反射

28.接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义（规范性）一个类可以实现一个或多个接口（扩展）。接口中可以定义常量，但不能有实例域和实现方法。接口变量必须引用实现了该接口的类对象

29.抽象类表示通用属性存在问题：每个类只能扩展一个类，但每个类可以实现多个接口。Java不支持多继承，皆苦可以提供多继承的大多数好处，同时能够避免多继承的复杂性和低效率

30.默认的克隆操作是浅拷贝，它并没有克隆包含在对象中的内部对象，导致原始对象和克隆对象共享这部分信息；当内部对象是可变的，必须重新定义clone方法，以便实现克隆内部对象的深拷贝

31.使用内部类的原因：
- 内部类方法可以访问创建它的外围类对象的数据域，包括私有的数据
- 内部类可以对同一个包中的其他类隐藏起来
- 当想要定义一个回调函数而且不想编写大量代码时，使用匿名内部类比较便捷

32.集合类的基本接口是Collection，除了以Map结尾的类外（实现了Map接口），其他常见集合类都实现了该接口，该接口扩展了Interable接口，所以对于标准类库中的任何集合都可以使用"for each"循环，元素被访问的顺序取决于集合类型。Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vetcor对象，如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间，ArrayList是不同步的。集合包是Java中最常用的包，它最常用的有Collection和Map两个接口的实现类，Collection用于存放多个单对象，Map用于存放Key-Value形式的键值对。Collection中常用的又分为两种类型的接口：List和Set，两者最明显的差别为List支持放入重复的对象，而Set不支持。List接口常用的实现类有：ArrayList，LinkedList，Vector和Stack；Set接口常用的实现有HashSet（无序）,TreeSet（有序，红黑树实现）。而Map的常用实现有TreeMap（有序）、HashMap（无序）、WeakHashMap
