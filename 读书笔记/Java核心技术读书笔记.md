## Java笔记
1.数据类型：整型（int, short, long, byte），浮点型（float, double），字符类型（char），布尔类型（boolean）  
位运算符：&（与）、|（或）、^（异或）、~（非） 

2.StringBuffer是线程安全的，效率稍低，允许采用多线程的方式执行添加或删除字符的操作；如果所有字符串在一个单线程中编辑，则应该用StringBuilder替代

3.switch的case标签可以是类型为char、short、byte、int（或其包装器类Character、Short、Byte、Integer）的常量表达式；枚举常量；从Java 7.0开始，可以是字符串

4.允许将一个数组变量拷贝给另一个数组变量，两个变量将引用同一个数组；快速打印二维数组可以调用Arrays.deepToString(a)

5.类之间的关系
- 依赖（uses-a），如果类A的方法操纵类B的对象，则是类A依赖于类B，A本身并不需要引用B的实例作为成员变量；虚线箭头从A指向B；应尽可能将相互依赖的类减至最少，降低耦合度
- 聚合（has-a），类A的对象包含类B的对象
- 继承（is-a），实线空心三角箭头
- 接口实现，虚线空心三角箭头

6.一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用

7.在每一个方法中，关键字this表示隐式参数；参数有两种类型：基本数据类型和对象引用

8.注意不要编写返回引用可变对象的访问器方法，如果需要应该首先对它进行克隆

9.类的静态方法不能操作类对象，可以认为静态方法是没有this参数的方法，以下情况下使用静态方法：
- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
- 一个方法只需访问类的静态域
- 类使用工厂方法产生不同风格的格式对象 

10.按值调用表示方法接受的是调用者提供的值；按引用调用表示方法接受的是调用者提供的变量地址；一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java总是采用按值调用，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容

11.不能有两个名字相同、参数类型也相同却返回不同类型值的方法；方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。允许子类将覆盖方法的返回类型定义为原返回类型的子类型

12.调用构造器步骤：
1. 所有数据域被初始化为默认值
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
4. 执行这个构造器的主体

13.finalize方法将在垃圾回收器清除对象之前调用，不要依赖使用finalize方法回收任何短缺的资源

14.Java中所有继承都是公有继承，没有C++中的私有继承和保护继承；子类不能直接地访问超类的私有域

15.如果子类的构造器没有显式地调用超类的构造器，则自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中没有显式地调用超类的其他构造器，则Java编译器报错

16.this用途：一是引用隐式参数，二是调用该类的其他构造器；super用途：一是调用超类的方法，二是调用超类的构造器

17.一个对象变量可以指示多种实际类型的现象被称为多态，Java中对象变量是多态的，一个超类变量既可以引用一个超类对象，也可以引用超类的任何一个子类的对象，也可以称为置换法则。可以将一个子类对象赋值给超类变量，但不能将一个超类的引用赋值给子类变量

17.在运行时能够自动地选择调用哪个方法的现象称为动态绑定，下面是调用对象方法的过程：
- 编译器查看对象的声明类型和方法名
- 编译器将查看调用方法时提供的参数类型
- 如果是private、static、final方法或构造器，那个编译器将可以准确地知道应该调用哪个方法，即静态绑定
- 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与所引用对象的实际类型最适合的那个类的方法。虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法  

18.在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别地，如果超类方法是public，子类方法一定要声明为public

19.阻止继承：final类和方法。不允许被继承的类被称为final类，类中的特定方法也能被声明为final，这时子类不能覆盖该方法；如果将一个类声明为final，只有其中的方法自动地成为final，不包括域。主要目的是确保它们不会在子类中改变语义

20.只能在继承层次内进行类型转换；在将超类转换成子类之前，应该使用instanceof进行检查。一般情况下，应该尽量少用类型转换和instanceof运算符

21.类即使不含抽象方法，也可以将类声明为抽象类；抽象类不能被实例化，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象

22.访问修饰符：
- 仅对本类可见-private
- 对所有类可见-public
- 对本包和所有子类可见-protected
- 对本包可见-默认，不需要修饰符   

23.Java中，只有基本类型不是对象；所有的数组类型，不管是对象数组还是基本类型数组都扩展与Object类

24.Java语言要求equals具有以下特性：自反性、对称性、传递性、一致性、对于任何非空引用x,x.equals(null)返回false。如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测；如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较

25.对象包装器（Integer、Long等）是不可变的，即一旦构造了包装器，就不予许更改包装在其中的值。同时，对象包装器还是final，因此不能定义他们的子类

26.能够分析类能力的程序称为反射。反射机制可以用来：
- 在运行中分析类的能力
- 在运行中查看对象，例如编写一个toString方法供所有类使用
- 实现通用的数组操作代码
- 利用Method对象，这个对象很像C++中的函数指针

27.继承设计技巧
- 将公共操作和域放在超类
- 不要使用受保护的域
- 使用继承实现"is-a"关系
- 除非所有继承的方法都有意义，否则不要使用继承
- 在覆盖方法时，不要改变预期的行为
- 使用多态，而非类型信息
- 不要过多地使用反射

28.接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义（规范性）一个类可以实现一个或多个接口（扩展）。接口中可以定义常量，但不能有实例域和实现方法。接口变量必须引用实现了该接口的类对象

29.抽象类表示通用属性存在问题：每个类只能扩展一个类，但每个类可以实现多个接口。Java不支持多继承，皆苦可以提供多继承的大多数好处，同时能够避免多继承的复杂性和低效率

30.默认的克隆操作是浅拷贝，它并没有克隆包含在对象中的内部对象，导致原始对象和克隆对象共享这部分信息；当内部对象是可变的，必须重新定义clone方法，以便实现克隆内部对象的深拷贝

31.使用内部类的原因：
- 内部类方法可以访问创建它的外围类对象的数据域，包括私有的数据
- 内部类可以对同一个包中的其他类隐藏起来
- 当想要定义一个回调函数而且不想编写大量代码时，使用匿名内部类比较便捷

32.集合类的基本接口是Collection，除了以Map结尾的类外（实现了Map接口），其他常见集合类都实现了该接口，该接口扩展了Interable接口，所以对于标准类库中的任何集合都可以使用"for each"循环，元素被访问的顺序取决于集合类型。Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vetcor对象，如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间，ArrayList是不同步的。集合包是Java中最常用的包，它最常用的有Collection和Map两个接口的实现类，Collection用于存放多个单对象，Map用于存放Key-Value形式的键值对。Collection中常用的又分为两种类型的接口：List和Set，两者最明显的差别为List支持放入重复的对象，而Set不支持。List接口常用的实现类有：ArrayList，LinkedList，Vector和Stack；Set接口常用的实现有HashSet（无序）,TreeSet（有序，红黑树实现）。而Map的常用实现有TreeMap（有序）、HashMap（无序）、WeakHashMap

33.多进程和多线程的本质区别在于每个进程拥有自己的一整套变量，而线程则共享数据，共享变量使得线程之间通信比进程之间的通信更有效、更容易，线程更轻量级，创建、撤销一个线程比启动新进程的开销小得多；不要调用Thread或者Runnable对象的run方法，直接调用run方法，只会执行同一个线程中的任务，而不会启动新的线程；当对一个线程调用interrupt方法时，线程的中断状态将设置成true，如果线程被阻塞，就无法检测中断状态，这是产生InterruptedException异常的地方，当在一个被阻塞的线程（调用sleep或者wait）上调用interrupt方法时，阻塞调用将会被InterruptedException异常中断，interrupted()测试当前线程是否被中断，是一个静态方法，它将当前线程的中断状态重置为false，isInterrupted()这一调用不改变线程的中断状态

34.线程状态（调用getState()）
- New（新创建）：new 操作符创建一个新线程
- Runnable（可运行）：调用start方法，线程处于runnable状态；一个可运行的线程可能正在运行也可能没有运行，也不必始终保持运行，运行中线程被中断是为了让其他线程获得运行机会。抢占式调度系统分配时间片给每一个可运行线程执行任务，时间片用完，操作系统剥夺该线程的运行权，选择下一个线程时，考虑线程的优先级
- Blocked（被阻塞）：当线程试图获取一个内部对象锁，而该锁被其他线程持有，则该线程进入阻塞状态
- Waiting（等待）：当线程等待另一个线程通知调度器一个条件时，它进入等待状态；在调用Object.wait或Thread.join方法，或者等待java.util.concurrent库中的Lock或Conditioon
- Timed waiting（计时等待）：如调用Thread.sleep、Object.wait等
- Terminated（被终止）：运行run方法正常退出而自然死亡；因为没有捕获的异常导致终止了run方法而意外死亡

35.线程属性
- 线程优先级：调用setPriority设置优先级（1-10），一个线程继承它父类线程的优先级；调用静态方法yield()方法导致当前执行线程处于让步状态
- 守护线程：调用setDDaemon(true)将线程转换为守护线程，必须在启动线程之前调用，唯一用途是为其他线程提供服务，当只剩下守护线程时，虚拟机就退出了；守护线程应该永远不去访问固有资源，如文件、数据库
- 未捕获异常处理器：线程的run方法不能抛出任何被检测的异常，不使用catch字句而在线程死亡前将异常传递到一个用于未捕获异常处理器
- 线程组：如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象

36.使用synchronized、锁和对象防止代码块受并发访问的干扰
- 锁对象：使用new ReentrantLock().lock()确保任何时刻只有一个线程进入临界区；一旦一个线程封锁了锁对象，其它任何线程都无法通过lock语句，会被阻塞
- 条件对象：使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。一个锁对象可以有一个或多个相关的条件对象，使用newCondition获得一个条件对象，条件对象调用await()方法阻塞当前线程，并放弃锁；当锁可用时，该线程不能马上解除阻塞，相反，它处于阻塞状态，直到另一个线程调用用一条件上的signalAll方法时为止
- synchronized：Java中每一个对象都有一个内部锁，如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法，调用该方法线程必须获得内部的对象锁，并且该锁有一个内部条件

37.volatile关键字为实例域的同步访问提供了一个免锁机制，能标识该域可能被另一个线程并发更新，volatile变量不能提供原子性
