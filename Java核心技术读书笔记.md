## Java笔记
1.数据类型：整型（int, short, long, byte），浮点型（float, double），字符类型（char），布尔类型（boolean）  
位运算符：&（与）、|（或）、^（异或）、~（非）  
2.StringBuffer是线程安全的，效率稍低，允许采用多线程的方式执行添加或删除字符的操作；如果所有字符串在一个单线程中编辑，则应该用StringBuilder替代  
3.switch的case标签可以是类型为char、short、byte、int（或其包装器类Character、Short、Byte、Integer）的常量表达式；枚举常量；从Java 7.0开始，可以是字符串  
4.允许将一个数组变量拷贝给另一个数组变量，两个变量将引用同一个数组；快速打印二维数组可以调用Arrays.deepToString(a)  
5.类之间的关系
- 依赖（uses-a），如果类A的方法操纵类B的对象，则是类A依赖于类B，A本身并不需要引用B的实例作为成员变量；虚线箭头从A指向B；应尽可能将相互依赖的类减至最少，降低耦合度
- 聚合（has-a），类A的对象包含类B的对象
- 继承（is-a），实线空心三角箭头
- 接口实现，虚线空心三角箭头

6.一个对象变量并没有实际包含一个对象，而仅仅引用一个对象，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用  
7.在每一个方法中，关键字this表示隐式参数；参数有两种类型：基本数据类型和对象引用  
8.注意不要编写返回引用可变对象的访问器方法，如果需要应该首先对它进行克隆  
9.类的静态方法不能操作类对象，可以认为静态方法是没有this参数的方法，以下情况下使用静态方法：
- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
- 一个方法只需访问类的静态域
- 类使用工厂方法产生不同风格的格式对象 

10.按值调用表示方法接受的是调用者提供的值；按引用调用表示方法接受的是调用者提供的变量地址；一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java总是采用按值调用，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容  
11.不能有两个名字相同、参数类型也相同却返回不同类型值的方法；方法的名字和参数列表称为方法的签名，返回类型不是签名的一部分。允许子类将覆盖方法的返回类型定义为原返回类型的子类型  
12.调用构造器步骤：
1. 所有数据域被初始化为默认值
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
4. 执行这个构造器的主体

13.finalize方法将在垃圾回收器清除对象之前调用，不要依赖使用finalize方法回收任何短缺的资源  
14.Java中所有继承都是公有继承，没有C++中的私有继承和保护继承；子类不能直接地访问超类的私有域  
15.如果子类的构造器没有显式地调用超类的构造器，则自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中没有显式地调用超类的其他构造器，则Java编译器报错  
16.this用途：一是引用隐式参数，二是调用该类的其他构造器；super用途：一是调用超类的方法，二是调用超类的构造器  
17.一个对象变量可以指示多种实际类型的现象被称为多态，Java中对象变量是多态的，一个超类变量既可以引用一个超类对象，也可以引用超类的任何一个子类的对象，也可以称为置换法则。可以将一个子类对象赋值给超类变量，但不能将一个超类的引用赋值给子类变量  
17.在运行时能够自动地选择调用哪个方法的现象称为动态绑定，下面是调用对象方法的过程：
- 编译器查看对象的声明类型和方法名
- 编译器将查看调用方法时提供的参数类型
- 如果是private、static、final方法或构造器，那个编译器将可以准确地知道应该调用哪个方法，即静态绑定
- 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与所引用对象的实际类型最适合的那个类的方法。虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法  

18.在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别地，如果超类方法是public，子类方法一定要声明为public  
19.阻止继承：final类和方法。不允许被继承的类被称为final类，类中的特定方法也能被声明为final，这时子类不能覆盖该方法；如果将一个类声明为final，只有其中的方法自动地成为final，不包括域。主要目的是确保它们不会在子类中改变语义  
20.只能在继承层次内进行类型转换；在将超类转换成子类之前，应该使用instanceof进行检查。一般情况下，应该尽量少用类型转换和instanceof运算符  
21.类即使不含抽象方法，也可以将类声明为抽象类；抽象类不能被实例化，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象  
22.访问修饰符：
- 仅对本类可见-private
- 对所有类可见-public
- 对本包和所有子类可见-protected
- 对本包可见-默认，不需要修饰符   

23.Java中，只有基本类型不是对象；所有的数组类型，不管是对象数组还是基本类型数组都扩展与Object类
